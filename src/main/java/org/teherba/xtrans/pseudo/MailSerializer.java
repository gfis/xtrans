/*  Pseudo transformer which serializes an XML representation of an EMail; 
	cannot generate XML
    @(#) $Id: MailSerializer.java 566 2010-10-19 16:32:04Z gfis $
    2008-04-22, Dr. Georg Fischer
*/
/*
 * Copyright 2008 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.teherba.xtrans.pseudo;
import  org.teherba.xtrans.CharTransformer;
import  java.util.Date;
import  java.util.Properties;
import  javax.mail.Message;
import  javax.mail.Multipart;
import  javax.mail.Session;
import  javax.mail.Transport;
import  javax.mail.internet.InternetAddress;
import  javax.mail.internet.MimeBodyPart;
import  javax.mail.internet.MimeMessage;
import  javax.mail.internet.MimeMultipart;
import  javax.activation.DataHandler;
import  javax.activation.FileDataSource;
import  javax.activation.MimetypesFileTypeMap;
import  org.xml.sax.Attributes;
import  org.apache.log4j.Logger;

/**	Pseudo transformer which serializes an XML representation of an EMail; 
 *	cannot generate XML. The input contains 
 *	the sender's and recipient's address, 
 *	the subject,
 *	the first body part (text) and 
 *	the types and names of any local files which should be attached.
 *  @author Dr. Georg Fischer
 */
public class MailSerializer extends CharTransformer { 
    public final static String CVSID = "@(#) $Id: MailSerializer.java 566 2010-10-19 16:32:04Z gfis $";

    /** log4j logger (category) */
    private Logger log;
    
    /** Root element tag */
    private static final String ROOT_TAG   	= "mail";
    /** sender's address element tag */
    private static final String FROM_TAG    = "from";
    /** recipient's address element tag */
    private static final String TO_TAG      = "to";
    /** recipient's address element tag */
    private static final String CC_TAG      = "cc";
    /** recipient's address element tag */
    private static final String BCC_TAG     = "bcc";
    /** Subject element tag */
    private static final String SUBJECT_TAG = "subject";
    /** File element tag */
    private static final String FILE_TAG    = "file";
    /** Type attribute name */
    private static final String TYPE_ATTR   = "type";

    /** Constructor.
     */
    public MailSerializer() {
        super();
        setFormatCodes("mail");
        setDescription("mailer for multipart messages");
        setFileExtensions(".");
    } // Constructor
    
	/** Initializes the (quasi-constant) global structures and variables.
	 *  This method is called by the {@link org.teherba.xtrans.XtransFactory} once for the
	 *  selected generator and serializer.
	 */
	public void initialize() {
		super.initialize();
        log = Logger.getLogger(MailSerializer.class.getName());
	} // initialize

    /** Transforms from the specified format to XML
     *  @return whether the transformation was successful
     */
    public boolean generate() {
        boolean result = false;
		log.warn("xtrans.MailSerializer cannot generate XML");
        return  result;
    } // generate

    /*===========================*/
    /* SAX handler for XML input */
    /*===========================*/

    /** Upper bound for character buffer */
    protected static final int MAX_BUF = 4096;
    /** buffer for portions of the input elements */
    protected StringBuffer saxBuffer;
    /** MIME type of current file, from <em>type</em> attribute or guessed */
    protected String mimeType;
    /** map from mime types to file extensions */
    protected MimetypesFileTypeMap mimeTypeMap;
    /** message to be sent */
    protected Message message;
    /** multipart for the attachments */
    protected Multipart parts;
    
    /** Receive notification of the beginning of the document.
     */
    public void startDocument() {
        saxBuffer   = new StringBuffer(MAX_BUF); // a rather long portion
		try {
			mimeTypeMap = new MimetypesFileTypeMap();
			Properties props = new Properties();
			props.put("mail.smtp.host", "localhost");
			Session session = Session.getInstance(props, null);
			session.setDebug(true);
			session.setDebug(false);
		    message = new MimeMessage(session);
		    message.setSentDate(new Date());
		    parts = new MimeMultipart();
		    MimeBodyPart part1 = new MimeBodyPart();
		    part1.setText("This email was automatically generated by xtrans.MailSerializer.");
		    parts.addBodyPart(part1);
		} catch (Exception exc) {
		    log.error(exc.getMessage(), exc);
		}
    } // startDocument

    /** Receive notification of the end of the document.
     */
    public void endDocument() {
		try {
		    message.setContent(parts);
		    Transport.send(message);
		} catch (Exception exc) {
		    log.error(exc.getMessage(), exc);
		}
    } // endDocument
    
    /** Receive notification of the start of an element.
     *  Looks for the element which contains raw lines.
     *  @param uri The Namespace URI, or the empty string if the element has no Namespace URI 
     *  or if Namespace processing is not being performed.
     *  @param localName the local name (without prefix), 
     *  or the empty string if Namespace processing is not being performed.
     *  @param qName the qualified name (with prefix), 
     *  or the empty string if qualified names are not available.
     *  @param attrs the attributes attached to the element. 
     *  If there are no attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String localName, String qName, Attributes attrs) {
        if (namespace.length() > 0 && qName.startsWith(namespace)) {
            qName = qName.substring(namespace.length());
        }
        if (false) {
        } else if (qName.equals(FROM_TAG)) {
            saxBuffer.setLength(0);
        } else if (qName.equals(SUBJECT_TAG)) {
            saxBuffer.setLength(0);
        } else if (qName.equals(TO_TAG)) {
            saxBuffer.setLength(0);
        } else if (qName.equals(CC_TAG)) {
            saxBuffer.setLength(0);
        } else if (qName.equals(BCC_TAG)) {
            saxBuffer.setLength(0);
        } else if (qName.equals(FILE_TAG)) {
            mimeType = attrs.getValue(TYPE_ATTR);
            saxBuffer.setLength(0);
        } // else ignore unknown elements
    } // startElement
    
    /** Receive notification of the end of an element.
     *  Looks for the element which contains raw lines.
     *  Terminates the line.
     *  @param uri the Namespace URI, or the empty string if the element has no Namespace URI 
     *  or if Namespace processing is not being performed.
     *  @param localName the local name (without prefix), 
     *  or the empty string if Namespace processing is not being performed.
     *  @param qName the qualified name (with prefix), 
     *  or the empty string if qualified names are not available.
     */
    public void endElement(String uri, String localName, String qName) {
        if (namespace.length() > 0 && qName.startsWith(namespace)) {
            qName = qName.substring(namespace.length());
        }
		try {
	        if (false) {
	        } else if (qName.equals(FROM_TAG)) {
			    message.setFrom(new InternetAddress(saxBuffer.toString()));
	        } else if (qName.equals(SUBJECT_TAG)) {
			    message.setSubject(saxBuffer.toString());
	        } else if (qName.equals(TO_TAG)) {
			    message.addRecipient(Message.RecipientType.TO , new InternetAddress(saxBuffer.toString()));
	        } else if (qName.equals(CC_TAG)) {
			    message.addRecipient(Message.RecipientType.CC , new InternetAddress(saxBuffer.toString()));
	        } else if (qName.equals(BCC_TAG)) {
			    message.addRecipient(Message.RecipientType.BCC, new InternetAddress(saxBuffer.toString()));
	        } else if (qName.equals(FILE_TAG)) {
	        	String fileName = saxBuffer.toString();
	        	String lowerName = fileName.toLowerCase();
		       	if (mimeType == null) { // no attribute: guess it
					mimeType = mimeTypeMap.getContentType(fileName);
	        	} // no type attribute
				// System.err.println("fileName=\"" + fileName + "\", type=\"" + mimeType + "\";");
			    MimeBodyPart part = new MimeBodyPart();
				if (mimeType == null) {
				    part.attachFile(fileName);
				} else { // mimeType was specified
			   	    FileDataSource fds = new FileDataSource(fileName) {
			   	    	String typeCopy = mimeType;
						public String getContentType() {
						    return typeCopy;
						}
					};
				    part.setDataHandler(new DataHandler(fds));
				    part.setFileName(fds.getName());
				} 
			    parts.addBodyPart(part);	        	
	        } else if (qName.equals(ROOT_TAG)) {
	            // finish and send the message
	            
	        } // else ignore unknown elements
		} catch (Exception exc) {
		    log.error(exc.getMessage(), exc);
		}
    } // endElement
    
    /** Receive notification of character data inside an element.
     *  @param ch the characters.
     *  @param start the start position in the character array.
     *  @param length the number of characters to use from the character array. 
     */
    public void characters(char[] ch, int start, int length) {
        saxBuffer.append(new String(ch, start, length));
    } // characters

} // MailSerializer
